---
title: opencv图像变换 
key: 2022-08-07
tags: 
- opencv
- 计算机视觉
modify_date: 2022-08-07
author: 徐文江
show_author_profile: true
---


# 图像金字塔         
图像金字塔是图像的集合，由单个原始图像产生，连续降采样，知道达到一些期望的停止点（可能是单像素图像）    
<!--more-->     
高斯金字塔：降采样图像    
拉普拉斯金字塔：从金字塔中较低的图像重构上采样图像     

cv::pyrDown()：将层与高斯核卷积，去除每个偶数行和列，生成下一层，恰好为前身的四分之一    

cv::buildPyramid()：生成一系列新图像     

cv::pyrUp()：首先将图像大小增加到每个维度的两倍，新行填充0，使用高斯滤波器卷积近似“丢失”像素的值    


## 拉普拉斯金字塔     
pyrUp不是pyrDown的逆，因为pyrDown会丢失信息    
为恢复原始（较高分辨率）的图像，需要访问采样过程丢失的信息，形成拉普拉斯金字塔          

拉普拉斯金字塔每一层定义为该层图像减去下一层图像的pyrUp     

# 不均匀映射   

仿射变换（2x3）：必须保持矩形两边平行，可以旋转缩放挤压    
透视变换（3x3）：将矩形转换为任意四边形    

## 仿射变换   

密集仿射变换函数cv::warpAffine（）：图像扭曲必须处理内插使输出图像平滑自然     


计算仿射映射矩阵cv::getAffineTransform()：给定两个图像求仿射矩阵     

cv::transform()用于稀疏仿射变换：即单个点的列表的映射

cv::invertAffineTransform()用于逆仿射变换：将所有的转换点放回原来的地方    
（这一节有点不太懂）        

## 透视变换    
透视投影不是线性变换，因为需要通过最终维度进行划分，从而失去一个维度   

cv::warpPerspective()用于密集透视变换：

cv::getPerspectiveTransform()用于计算透视映射矩阵     

cv::perspectiveTransform()用于稀疏透视变换：对点列表执行透视变换。因为cv::transform限定于线性运算，不能正确处理透视变换    
实际上是将嵌入在三维空间中的二维平面上的点映射回到不同的二维子空间      


# 通用变换    

## 极坐标映射    
cv::cartToPolar()用于将直角坐标转换为极坐标：可以用于后续梯度统计直方图    
cv::polarToCart()用于将极坐标转换为直角坐标     

## LogPolar    
将ρ放入对数log，形成对数-极坐标    
眼睛感官的密度从中心向四周快速降低（指数级）     
而且，对数-极坐标变换可以用来创建对象视图的固定二维表示法，即二维图像的旋转缩放不变性    

cv::logPolar()函数用于对数-极坐标变换    

## 任意映射  
cv::remap()用于常规图像重绘    


# 图像修复    
通过摄取被损坏区域边缘的色彩和纹理，传播混合至损坏区域的内部    

## 图像修复cv:inpaint()    
不能修复完全被消除的纹理    

## 去噪   
噪声的主要来源是低光条件的影响，低光下数字成像器的增益必须增加，噪声也被放大，这些噪声是随即独立的像素     

opencv中的去噪算法是快速非局部均值去噪（FNLMD），中心概念是在图像中其他地方寻找类似的像素，再对其取平均。     
像素被认为是相似的像素，是因为他在环境中是相似的（关键是许多图像包含重复的结构）     





































## [写两句?](https://github.com/HEA1OR/HEA1OR.github.io/tree/master/_posts)

